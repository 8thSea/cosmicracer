<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Racer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: #000000;
            color: white;
        }

        /* --- Screens (Start & Game Over) --- */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #000000, #110022);
            z-index: 100;
            text-align: center;
        }
        
        .content-box {
            background: rgba(20, 20, 40, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid #9933ff;
            box-shadow: 0 0 30px rgba(153, 51, 255, 0.5);
        }
        
        h1 {
            font-size: 48px;
            margin: 0 0 30px 0;
            color: #cc99ff;
            text-shadow: 0 0 20px rgba(204, 153, 255, 0.8);
        }

        /* --- Character Selection --- */
        .characters {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .character {
            padding: 15px 25px;
            font-size: 40px;
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }
        
        .character:hover {
            transform: scale(1.2);
            border-color: #9933ff;
            box-shadow: 0 0 20px rgba(153, 51, 255, 0.8);
        }
        
        .character.selected {
            border-color: #9933ff;
            transform: scale(1.1);
        }
        
        /* --- Buttons --- */
        button {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #cc99ff, #6633cc);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(153, 51, 255, 0.8);
        }

        /* --- In-Game UI --- */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 50;
        }
        
        .ui-element {
            margin-bottom: 12px;
            background: rgba(20, 20, 40, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            min-width: 150px;
            border: 1px solid #6633cc;
        }

        /* --- UI Bars (Health/Boost) --- */
        .bar-container {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-top: 5px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            border-radius: 6px;
            transition: width 0.2s ease-out;
        }

        #healthBar { background-color: #33ff66; }
        #boostBar { background-color: #ffaa33; }
        #bombRegenBar { background-color: #9933ff; } /* New: Bomb regen bar color */
        
        /* --- Controls Info --- */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 50;
        }

        /* --- Leaderboard Styles --- */
        #leaderboard {
            margin-top: 30px;
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #6633cc;
        }

        #leaderboard h2 {
            color: #cc99ff;
            margin-top: 0;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(204, 153, 255, 0.5);
        }

        #leaderboard ol {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #leaderboard li {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
            font-size: 18px;
        }

        #leaderboard li:last-child {
            border-bottom: none;
        }

        #leaderboard li span:first-child {
            font-weight: bold;
            color: #ffcc66;
        }
        
        #userIdDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            background: rgba(20, 20, 40, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #6633cc;
            z-index: 50;
        }

        /* Ensure the canvas covers the entire screen */
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; /* Ensure it's above body background but below UI */
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body tabindex="0"> <!-- Added tabindex="0" to make body focusable -->
    <!-- In-Game UI -->
    <div id="ui" class="hidden">
        <div class="ui-element">Score: <span id="score">0</span></div>
        <div class="ui-element">Distance: <span id="distance">0</span>km</div>
        <div class="ui-element">
            Hull Integrity
            <div class="bar-container"><div id="healthBar" class="bar-fill"></div></div>
        </div>
        <div class="ui-element">
            Thrusters
            <div class="bar-container"><div id="boostBar" class="bar-fill"></div></div>
        </div>
        <div class="ui-element">
            Bombs: <span id="bombStatus">Ready</span>
            <div class="bar-container"><div id="bombRegenBar" class="bar-fill"></div></div>
        </div>
    </div>
    
    <!-- User ID Display -->
    <div id="userIdDisplay" class="hidden">
        User ID: <span id="currentUserId">Loading...</span>
    </div>

    <!-- Controls Display -->
    <div id="controls" class="hidden">
        üéÆ Arrow Keys/WASD: Steer ‚Ä¢ Space: Thrusters ‚Ä¢ X: Fire ‚Ä¢ P: Pause ‚Ä¢ Z: Bomb
    </div>
    
    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <div class="content-box">
            <h1>üöÄ Cosmic Racer üå†</h1>
            <p style="font-size: 20px;">Choose your ship:</p>
            <div class="characters">
                <div class="character" data-type="rocket">üöÄ</div>
                <div class="character" data-type="ufo">üõ∏</div>
                <div class="character" data-type="satellite">üõ∞Ô∏è</div>
                <div class="character" data-type="alien">üëΩ</div>
            </div>
            <button id="startButton">Launch!</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen hidden">
        <div class="content-box">
            <h1>Mission Failed</h1>
            <p style="font-size: 22px;">Final Score: <span id="finalScore">0</span></p>
            <div id="leaderboard">
                <h2>Leaderboard</h2>
                <p id="leaderboardStatus">Loading scores...</p>
                <ol id="leaderboardList"></ol>
            </div>
            <button id="restartButton">Relaunch</button>
        </div>
    </div>

    <!-- Pause Screen (NEW) -->
    <div id="pauseScreen" class="screen hidden">
        <div class="content-box">
            <h1>Game Paused</h1>
            <button id="resumeButton">Resume Game</button>
            <button id="pauseRestartButton" style="margin-top: 15px;">Restart Mission</button>
            <button id="mainMenuButton" style="margin-top: 15px;">Back to Main Menu</button>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (accessible from the main script)
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;

        // Initialize Firebase
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        if (Object.keys(firebaseConfig).length > 0) {
            window.firebaseApp = initializeApp(firebaseConfig);
            window.db = getFirestore(window.firebaseApp);
            window.auth = getAuth(window.firebaseApp);

            onAuthStateChanged(window.auth, async (user) => {
                if (user) {
                    window.userId = user.uid;
                    document.getElementById('currentUserId').textContent = window.userId;
                } else {
                    // Sign in anonymously if no user is authenticated
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(window.auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(window.auth);
                        }
                    } catch (error) {
                        console.error("Firebase authentication error:", error);
                        document.getElementById('currentUserId').textContent = "Auth Error";
                    }
                }
                document.getElementById('userIdDisplay').classList.remove('hidden');
            });
        } else {
            console.warn("Firebase config not found. Leaderboard functionality will be disabled.");
            document.getElementById('currentUserId').textContent = "N/A (No Firebase)";
            document.getElementById('userIdDisplay').classList.remove('hidden');
        }
    </script>
    <script>
        // Game state variables
        let scene, camera, renderer;
        let player, playerType = 'rocket';
        let playerVelocity = { x: 0, y: 0 };
        let obstacles = [], collectibles = [];
        let score = 0, distance = 0;
        let speed = 0.8, baseSpeed = 0.8, boostSpeed = 0;
        
        // Game State Variables
        let health = 100;
        let boost = 100;
        let bombs = 1; // Start with 1 bomb
        let bombReady = true; // Is bomb available to use?
        let bombCooldownTimer = 0; // Timer for post-use cooldown
        let bombRegenTimer = 0; // Timer for regeneration progress
        const BOMB_USE_COOLDOWN = 3; // Seconds after use before regeneration starts
        const BOMB_REGEN_DURATION = 15; // Seconds to regenerate one bomb
        
        let isShieldActive = false;
        let shieldTimeout;
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameOver'
        
        let clock = new THREE.Clock();
        const keys = {};
        let sounds;
        let starfieldLayers = []; // Changed to array for multiple layers
        let isBoostingSoundPlaying = false;

        // Shooting variables
        let lasers = [];
        let rockets = []; // New: Array to hold rocket objects
        let laserCooldown = 0;

        // Graphical enhancement variables
        let distantPlanets = [];
        let nebulaPlanes = []; // To store references to nebula planes
        let distantAsteroidFields = []; // New: To store distant asteroid fields
        let explosionSoundCooldown = 0; // Cooldown for explosion sound
        let dynamicLight; // New: For dynamic lighting
        let secondaryDynamicLight; // New: For additional dynamic lighting

        // Alien variables
        let alienShips = [];
        // Increased alien spawn frequency
        let alienSpawnCooldown = 3; // Time in seconds before next alien can spawn (reduced for more aliens)
        let currentAlienSpawnTimer = alienSpawnCooldown;
        const ALIEN_LASER_SPEED = 50; // Slower alien lasers
        const ALIEN_SHOOT_COOLDOWN = 2.0; // Seconds between alien shots (increased)

        // New Alien Type 2 Constants (distinct properties)
        const ALIEN_TYPE2_HEALTH = 2; // Requires two hits
        const ALIEN_TYPE2_COLOR = 0x990099; // Magenta
        const ALIEN_TYPE2_LASER_COLOR = 0xffff00; // Yellow
        const ALIEN_TYPE2_SPEED_FACTOR = 0.8; // Slower than Type 1
        const ALIEN_TYPE2_SHOOT_COOLDOWN = 3.0; // Slower shooting

        // New Alien Type 3 Constants (Fast but fragile and erratic)
        const ALIEN_TYPE3_HEALTH = 1; // Fragile
        const ALIEN_TYPE3_COLOR = 0x00ffff; // Cyan
        const ALIEN_TYPE3_LASER_COLOR = 0xff00ff; // Pink
        const ALIEN_TYPE3_SPEED_FACTOR = 1.8; // Very fast
        const ALIEN_TYPE3_SHOOT_COOLDOWN = 1.0; // Shoots faster
        const ALIEN_TYPE3_TARGET_OFFSET_RANGE = 25; // Larger range for target offset to make its movement more erratic.
        const ALIEN_TYPE3_APPROACH_SPEED_FACTOR = 0.05; // Less precise approach, contributing to crashes.

        // New Alien Type 4 Constants (Tanky and Slow)
        const ALIEN_TYPE4_HEALTH = 5; // Very high health
        const ALIEN_TYPE4_COLOR = 0x800080; // Purple
        const ALIEN_TYPE4_LASER_COLOR = 0x00ff00; // Green
        const ALIEN_TYPE4_SPEED_FACTOR = 0.5; // Very slow
        const ALIEN_TYPE4_SHOOT_COOLDOWN = 4.0; // Very slow shooting
        const ALIEN_TYPE4_TARGET_OFFSET_RANGE = 5; // More precise targeting
        const ALIEN_TYPE4_APPROACH_SPEED_FACTOR = 0.02; // Very slow approach

        // Power-up variables
        let isTripleShotActive = false;
        let tripleShotTimeout = null;
        const TRIPLE_SHOT_DURATION = 7; // seconds
        let isSpeedBoostActive = false;
        let speedBoostTimeout = null;
        const SPEED_BOOST_DURATION = 5; // seconds
        const SPEED_BOOST_FACTOR = 0.7; // How much extra speed to add (e.g., 0.5 means 50% faster base speed)
        const HEALTH_PACK_AMOUNT = 30; // Health restored by health pack
        // All collectible types, including crystal, are now part of random spawning
        const COLLECTIBLE_TYPES = ['crystal', 'crystal', 'crystal', 'shield', 'health', 'boost', 'tripleShot', 'speedBoost']; // Increased crystal probability
        const ROCKET_EXPLOSION_RADIUS = 50; // Radius of rocket explosion (renamed from BOMB_RADIUS)
        const ROCKET_SPEED = 150; // Speed of the rocket
        const ROCKET_FUSE_DISTANCE = 100; // Distance rocket travels before exploding

        // Path variables are no longer used for specific crystal paths, but for general spread
        const RANDOM_SPAWN_AREA_RADIUS = 80; // Max distance from center for random spawns
        
        // Spawning control variables (increased frequency for density)
        let randomAsteroidSpawnTimer = 0;
        const RANDOM_ASTEROID_SPAWN_INTERVAL = 0.03; // Even more frequent asteroid spawns
        let powerupSpawnTimer = 0; // Timer for power-up spawning
        // Increased crystal spawn frequency
        const POWERUP_SPAWN_INTERVAL = 0.1; // Even more frequent power-up spawns


        // DOM Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const pauseScreen = document.getElementById('pauseScreen');
        const ui = document.getElementById('ui');
        const controls = document.getElementById('controls');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardStatus = document.getElementById('leaderboardStatus');

        const resumeButton = document.getElementById('resumeButton');
        const pauseRestartButton = document.getElementById('pauseRestartButton');
        const mainMenuButton = document.getElementById('mainMenuButton');

        // Event Listeners
        document.querySelectorAll('.character').forEach(char => {
            char.addEventListener('click', function() {
                document.querySelectorAll('.character').forEach(c => c.classList.remove('selected'));
                this.classList.add('selected');
                playerType = this.dataset.type;
            });
        });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);
        
        // Pause screen button listeners
        resumeButton.addEventListener('click', togglePause);
        pauseRestartButton.addEventListener('click', () => {
            togglePause(); // Unpause first if paused
            restartGame();
        });
        mainMenuButton.addEventListener('click', showStartScreen);

        document.querySelector('[data-type="rocket"]').click(); // Select rocket by default
        
        // Global Keydown/Keyup listeners (moved outside init)
        window.addEventListener('keydown', (e) => { 
            keys[e.key.toLowerCase()] = true; 
            if (e.key === ' ' || e.key === 'x' || e.key === 'z') e.preventDefault(); // Added 'z'
            // Changed pause key to 'p'
            if (e.key === 'p') {
                console.log("P key pressed. Calling togglePause(). Current gameState:", gameState); // Debug log
                togglePause();
            }
        });
        window.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
        });

        function initSounds() {
            sounds = {
                collect: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                shield: new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.3 } }).toDestination(),
                damage: new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination(),
                boost: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination(),
                laser: new Tone.Synth({ oscillator: { type: 'fmsine', modulationIndex: 10 }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination(),
                alienLaser: new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.2 } }).toDestination(), // New alien laser sound
                explosion: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(),
                powerup: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.1 } }).toDestination(), // New powerup sound
                bomb: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.8, sustain: 0, release: 0.5 } }).toDestination() // Changed 'brownian' to 'brown'
            };
            sounds.collect.volume.value = -6;
            sounds.shield.volume.value = -6;
            sounds.damage.volume.value = -6;
            sounds.boost.volume.value = -10;
            sounds.laser.volume.value = -12;
            sounds.alienLaser.volume.value = -10; // Alien laser volume
            sounds.explosion.volume.value = -4;
            sounds.powerup.volume.value = -8;
            sounds.bomb.volume.value = -2; // Bomb sound volume
        }

        function startGame() {
            console.log("startGame called.");
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden'); // Ensure game over screen is hidden
            pauseScreen.classList.add('hidden'); // Ensure pause screen is hidden
            ui.classList.remove('hidden');
            controls.classList.remove('hidden');
            gameState = 'playing';
            
            init(); // Initialize Three.js basic scene and renderer
            initSounds(); // Initialize sounds
            
            // Reset bomb state for new game
            bombs = 1;
            bombReady = true;
            bombCooldownTimer = 0;
            bombRegenTimer = 0;

            // Reset path variables (no longer used for path, but for general random spread)
            randomAsteroidSpawnTimer = 0; // Reset random asteroid timer
            powerupSpawnTimer = 0; // Reset power-up timer

            // Resume Tone.js context when game starts
            if (Tone.context.state !== 'running') {
                Tone.context.resume();
            }

            // Now that basic Three.js is set up, create game-specific elements
            createWorldElements(); // This calls createPlayer()
            
            // Initial spawn of random asteroids and power-ups to fill the visible area
            // Increased initial count for a fuller screen
            for (let i = 0; i < 200; i++) { // Increased initial asteroids for more density
                createRandomAsteroid(player.position.z - (Math.random() * 450) - 50); // From -50 to -500
            }
            for (let i = 0; i < 50; i++) { // Increased initial power-ups (including crystals) for more density
                spawnRandomPowerup(player.position.z - (Math.random() * 450) - 50); // From -50 to -500
            }

            animate(); // Start the animation loop AFTER world elements are created
            console.log("Game started, animate loop should be running.");
        }

        async function restartGame() {
            // Clear all objects from the scene
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            obstacles = []; collectibles = []; lasers = []; alienShips = []; rockets = []; // Clear rockets too
            distantPlanets = []; nebulaPlanes = []; distantAsteroidFields = []; // Clear graphical elements too
            starfieldLayers = []; // Clear starfield layers

            score = 0; distance = 0; health = 100; boost = 100;
            bombs = 1; // Reset bombs to 1
            bombReady = true;
            bombCooldownTimer = 0;
            bombRegenTimer = 0;

            // Reset timers
            randomAsteroidSpawnTimer = 0;
            powerupSpawnTimer = 0;

            playerVelocity = { x: 0, y: 0 }; // Reset player velocity
            speed = 0.8; baseSpeed = 0.8; boostSpeed = 0;
            isShieldActive = false;
            clearTimeout(shieldTimeout);
            explosionSoundCooldown = 0; // Reset sound cooldown
            currentAlienSpawnTimer = alienSpawnCooldown; // Reset alien spawn timer

            // Reset power-up states
            isTripleShotActive = false;
            if (tripleShotTimeout) clearTimeout(tripleShotTimeout);
            isSpeedBoostActive = false;
            if (speedBoostTimeout) clearTimeout(speedBoostTimeout);


            // Re-initialize Three.js before creating world elements
            init(); 
            createWorldElements(); // Re-create the world elements
            
            // Initial spawn of random asteroids and power-ups to fill the visible area
            for (let i = 0; i < 200; i++) { // Increased initial asteroids for more density
                createRandomAsteroid(player.position.z - (Math.random() * 450) - 50); 
            }
            for (let i = 0; i < 50; i++) { // Increased initial power-ups (including crystals) for more density
                spawnRandomPowerup(player.position.z - (Math.random() * 450) - 50); 
            }

            gameOverScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden'); // Ensure pause screen is hidden
            ui.classList.remove('hidden');
            controls.classList.remove('hidden');
            
            gameState = 'playing';
            animate(); // Restart animation loop
        }

        // Function to show the start screen
        function showStartScreen() {
            gameState = 'menu';
            gameOverScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            ui.classList.add('hidden');
            controls.classList.add('hidden');
            startScreen.classList.remove('hidden');

            // Dispose of Three.js scene and renderer to free up resources
            if (renderer) {
                renderer.dispose();
                // Ensure the canvas element is removed from the DOM
                if (renderer.domElement.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                }
                renderer = null; // Set to null so init() will re-create
                scene = null;
                camera = null;
            }
            // Suspend Tone.js context if it's active
            if (Tone.context.state !== 'suspended') {
                Tone.context.suspend();
            }
        }

        async function gameOver() {
            gameState = 'gameOver';
            ui.classList.add('hidden');
            controls.classList.add('hidden');
            pauseScreen.classList.add('hidden'); // Ensure pause screen is hidden
            document.getElementById('finalScore').textContent = Math.floor(score);
            gameOverScreen.classList.remove('hidden');

            // Suspend Tone.js context
            if (Tone.context.state !== 'suspended') {
                Tone.context.suspend();
            }

            // Submit and fetch leaderboard scores
            if (window.db && window.userId) {
                await submitScore(Math.floor(score));
                await fetchLeaderboard();
            } else {
                leaderboardStatus.textContent = "Leaderboard not available (Firebase not initialized).";
            }
        }

        // Function to toggle pause state
        function togglePause() {
            console.log("togglePause called. Current gameState:", gameState);
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseScreen.classList.remove('hidden');
                ui.classList.add('hidden');
                controls.classList.add('hidden');
                console.log("Game paused. Pause screen visible. UI hidden.");
                if (Tone.context.state !== 'suspended') {
                    Tone.context.suspend();
                    console.log("Tone context suspended.");
                }
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseScreen.classList.add('hidden');
                ui.classList.remove('hidden');
                controls.classList.remove('hidden');
                console.log("Game unpaused. Pause screen hidden. UI visible.");
                if (Tone.context.state !== 'running') {
                    Tone.context.resume();
                    console.log("Tone context resumed.");
                }
                animate(); // Resume animation loop
            }
        }


        async function submitScore(finalScore) {
            try {
                const scoresCollection = window.db.collection(`/artifacts/${__app_id}/public/data/leaderboard`);
                await scoresCollection.add({
                    userId: window.userId,
                    score: finalScore,
                    timestamp: new Date()
                });
                console.log("Score submitted successfully!");
            } catch (e) {
                console.error("Error adding document: ", e);
                leaderboardStatus.textContent = "Error submitting score.";
            }
        }

        async function fetchLeaderboard() {
            leaderboardStatus.textContent = "Loading scores...";
            leaderboardList.innerHTML = ''; // Clear previous list
            try {
                const scoresCollection = window.db.collection(`/artifacts/${__app_id}/public/data/leaderboard`);
                const q = scoresCollection.orderBy("score", "desc").limit(10);
                const querySnapshot = await q.get();

                if (querySnapshot.empty) {
                    leaderboardStatus.textContent = "No scores yet. Be the first!";
                    return;
                }

                leaderboardStatus.textContent = ""; // Clear loading status
                querySnapshot.forEach((doc, index) => {
                    const data = doc.data();
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `<span>${index + 1}. ${data.userId.substring(0, 8)}...</span> <span>${data.score}</span>`;
                    leaderboardList.appendChild(listItem);
                });
            } catch (e) {
                console.error("Error fetching documents: ", e);
                leaderboardStatus.textContent = "Error loading leaderboard.";
            }
        }


        function init() {
            console.log("init called - setting up Three.js basics.");
            // Ensure renderer is always created and sized correctly
            if (renderer) {
                // If renderer already exists, just update its size and aspect ratio
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            } else {
                // Create new renderer, scene, camera if they don't exist
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x110022, 0.005);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                camera.position.set(0, 5, 15);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                console.log("Renderer appended. Size:", window.innerWidth, "x", window.innerHeight);

                window.addEventListener('resize', onWindowResize);
            }
        }

        function createWorldElements() {
            console.log("createWorldElements called.");
            // Clear existing scene objects (except for the camera which is managed by init)
            const objectsToRemove = scene.children.filter(obj => obj !== camera);
            objectsToRemove.forEach(obj => scene.remove(obj));

            obstacles = []; collectibles = []; lasers = []; alienShips = []; rockets = [];
            distantPlanets = []; nebulaPlanes = []; distantAsteroidFields = [];
            starfieldLayers = [];

            // Add lights to the scene
            const ambientLight = new THREE.AmbientLight(0x604080, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            dynamicLight = new THREE.PointLight(0xffccaa, 0.8, 200);
            dynamicLight.position.set(0, 20, 0); 
            scene.add(dynamicLight);

            secondaryDynamicLight = new THREE.PointLight(0xaaffcc, 0.5, 150);
            secondaryDynamicLight.position.set(50, -30, 0);
            scene.add(secondaryDynamicLight);

            createBackground();
            createPlayer(); // Player must be created before nextPathSegmentZ is set
            
            console.log("Game world elements created. Player position:", player.position);
        }
        
        function createNebulaTexture() {
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size; canvas.height = size;
            const context = canvas.getContext('2d');
            context.fillStyle = 'black';
            context.fillRect(0, 0, size, size);
            
            for (let i = 0; i < 50; i++) { 
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = Math.random() * 250 + 100; 
                const gradient = context.createRadialGradient(x, y, 0, x, y, radius);
                
                const r1 = Math.floor(Math.random() * 150 + 50);
                const g1 = Math.floor(Math.random() * 100);
                const b1 = Math.floor(Math.random() * 150 + 100);
                const alpha1 = Math.random() * 0.5 + 0.1; 

                const r2 = Math.floor(Math.random() * 100);
                const g2 = Math.floor(Math.random() * 100);
                const b2 = Math.floor(Math.random() * 150 + 100);

                const color1 = `rgba(${r1}, ${g1}, ${b1}, ${alpha1})`;
                const color2 = `rgba(${r2}, ${g2}, ${b2}, 0)`;

                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createDistantAsteroidField(zPos, count, spread) {
            const field = new THREE.Group();
            const rockMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, flatShading: true });
            for (let i = 0; i < count; i++) {
                const size = 1 + Math.random() * 5; 
                const geometry = new THREE.DodecahedronGeometry(size, 0);
                const asteroid = new THREE.Mesh(geometry, rockMaterial);
                asteroid.position.set(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread,
                    zPos + (Math.random() - 0.5) * spread * 0.5
                );
                asteroid.rotation.x = Math.random() * Math.PI;
                asteroid.rotation.y = Math.random() * Math.PI;
                asteroid.rotation.z = Math.random() * Math.PI;
                asteroid.userData.rotationSpeed = new THREE.Vector3(Math.random() * 0.005 - 0.0025, Math.random() * 0.005 - 0.0025, Math.random() * 0.005 - 0.0025);
                field.add(asteroid);
            }
            field.userData.initialZ = zPos;
            scene.add(field);
            distantAsteroidFields.push(field);
        }

        function createBackground() {
            const createStars = (count, size, range, color, depth, speedFactor) => {
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = [];
                for (let i = 0; i < count; i++) {
                    starPositions.push(THREE.MathUtils.randFloatSpread(range), THREE.MathUtils.randFloatSpread(range), THREE.MathUtils.randFloatSpread(range) - depth);
                }
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                const starMaterial = new THREE.PointsMaterial({ color: color, size: size + Math.random() * 0.5 }); 
                const stars = new THREE.Points(starGeometry, starMaterial);
                stars.userData.speedFactor = speedFactor;
                scene.add(stars);
                return stars;
            };

            starfieldLayers.push(createStars(25000, 0.7, 2000, 0xffffff, 0, 0.05)); 
            starfieldLayers.push(createStars(15000, 0.5, 3000, 0xaaaaaa, 1000, 0.02)); 
            starfieldLayers.push(createStars(8000, 0.3, 4000, 0x888888, 2000, 0.01)); 
            starfieldLayers.push(createStars(4000, 0.2, 5000, 0x666666, 3000, 0.005)); 
            // New: Very distant starfield layer
            starfieldLayers.push(createStars(2000, 0.1, 8000, 0x555555, 4000, 0.001));

            for (let i = 0; i < 15; i++) { 
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    map: createNebulaTexture(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false,
                    opacity: 0.6 
                });
                const nebulaPlane = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), nebulaMaterial);
                nebulaPlane.position.set((Math.random() - 0.5) * 1500, (Math.random() - 0.5) * 1200, -1000 - Math.random() * 1000);
                nebulaPlane.rotation.z = Math.random() * Math.PI;
                scene.add(nebulaPlane);
                nebulaPlanes.push(nebulaPlane);
            }

            const createPlanet = (radius, color, zPos, xPos, yPos) => {
                const planetGeometry = new THREE.SphereGeometry(radius, 32, 32); 
                const planetMaterial = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.2 });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.set(xPos, yPos, zPos);
                scene.add(planet);
                distantPlanets.push(planet);
            };

            createPlanet(50, 0xAA66FF, -2000, -500, 300);
            createPlanet(30, 0xFF9966, -1500, 700, -400);
            createPlanet(70, 0x66CCFF, -2500, 0, 800);

            createDistantAsteroidField(-1000, 70, 500); 
            createDistantAsteroidField(-1800, 90, 600); 
            createDistantAsteroidField(-2500, 80, 400); 
        }
        
        function createPlayer() {
            const shipColors = { rocket: 0xff4444, ufo: 0x44ff44, satellite: 0xcccccc, alien: 0x9933ff };
            const mainColor = shipColors[playerType];
            
            player = new THREE.Group();
            
            let body, leftWing, rightWing, leftEngine, rightEngine;
            // Declare materials once at the top of the function
            const material = new THREE.MeshPhongMaterial({ color: mainColor, emissive: mainColor, emissiveIntensity: 0.4, flatShading: true });
            const darkMaterial = new THREE.MeshPhongMaterial({ color: mainColor * 0.8, emissive: mainColor * 0.2, flatShading: true });
            const engineMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, emissive: 0x333333, flatShading: true });
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 1 }); // Declared here

            switch(playerType) {
                case 'rocket':
                    body = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.5, 8), material);
                    body.rotation.x = Math.PI / 2;
                    player.add(body);

                    leftWing = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 0.5), darkMaterial);
                    leftWing.rotation.z = Math.PI / 2;
                    leftWing.position.set(-0.8, 0, 0.2);
                    player.add(leftWing);

                    rightWing = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 0.5), darkMaterial);
                    rightWing.rotation.z = Math.PI / 2;
                    rightWing.position.set(0.8, 0, 0.2);
                    player.add(rightWing);

                    leftEngine = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8, 8), engineMaterial);
                    leftEngine.rotation.x = Math.PI / 2;
                    leftEngine.position.set(-0.4, 0, 0.8);
                    player.add(leftEngine);

                    rightEngine = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8, 8), engineMaterial);
                    rightEngine.rotation.x = Math.PI / 2;
                    rightEngine.position.set(0.4, 0, 0.8);
                    player.add(rightEngine);
                    break;

                case 'ufo':
                    body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.5, 32), material);
                    body.position.y = 0.5;
                    player.add(body);

                    const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), darkMaterial);
                    cockpit.position.y = 0.25;
                    player.add(cockpit);

                    // lightMat is already declared, just use it
                    const lightSize = 0.3;
                    const ufoLight1 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMat);
                    ufoLight1.position.set(1.0, 0.2, 0);
                    player.add(ufoLight1);
                    const ufoLight2 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMat);
                    ufoLight2.position.set(-1.0, 0.2, 0);
                    player.add(ufoLight2);
                    const ufoLight3 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMat);
                    ufoLight3.position.set(0, 0.2, 1.0);
                    player.add(ufoLight3);
                    const ufoLight4 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMat);
                    ufoLight4.position.set(0, 0.2, -1.0);
                    player.add(ufoLight4);
                    break;

                case 'satellite':
                    body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 1.5), material);
                    player.add(body);

                    const panelMaterial = new THREE.MeshPhongMaterial({ color: 0x3366ff, emissive: 0x112255, flatShading: true });
                    const leftPanel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 1), panelMaterial);
                    leftPanel.position.set(-0.8, 0, 0);
                    player.add(leftPanel);
                    const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 1), panelMaterial);
                    rightPanel.position.set(0.8, 0, 0);
                    player.add(rightPanel);

                    const antenna = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.0, 8), engineMaterial);
                    antenna.position.set(0, 0.5, -1.0);
                    player.add(antenna);
                    break;

                case 'alien':
                    // New angular alien player ship design
                    const mainBody = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2.5, 4), material); // Pyramid-like body
                    mainBody.rotation.x = Math.PI / 2;
                    mainBody.position.z = 0.5;
                    player.add(mainBody);

                    const frontWing = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 0.5), darkMaterial);
                    frontWing.rotation.z = Math.PI / 2;
                    frontWing.position.set(0, 0.5, -0.5);
                    player.add(frontWing);

                    const backWing = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 0.5), darkMaterial);
                    backWing.rotation.z = Math.PI / 2;
                    backWing.position.set(0, -0.5, 1.5);
                    player.add(backWing);

                    const cockpitSphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), darkMaterial);
                    cockpitSphere.position.z = -0.8;
                    cockpitSphere.position.y = 0.5;
                    player.add(cockpitSphere);

                    // lightMat is already declared, just use it
                    const alienLight1 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), lightMat);
                    alienLight1.position.set(-0.7, 0.2, -1.5);
                    player.add(alienLight1);
                    const alienLight2 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), lightMat);
                    alienLight2.position.set(0.7, 0.2, -1.5);
                    player.add(alienLight2);
                    break;
            }

            player.thrusterParticles = new THREE.Group();
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending });
            
            for(let i = 0; i < 80; i++) { 
                const particleGeometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.15, 8, 8); 
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.userData.life = Math.random() * 1.5 + 0.5;
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 2 + 1
                );
                player.thrusterParticles.add(particle);
            }
            player.thrusterParticles.position.z = 1.0;
            player.add(player.thrusterParticles);


            const shieldGeo = new THREE.SphereGeometry(1.2, 16, 16); 
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.4, wireframe: true });
            player.shieldVisual = new THREE.Mesh(shieldGeo, shieldMat);
            player.shieldVisual.visible = false;
            player.add(player.shieldVisual);

            player.position.set(0, 0, 0);
            scene.add(player);
            console.log("Player created and added to scene. Initial position:", player.position);
        }

        function createAlienShip(zPos) {
            const alien = new THREE.Group();
            const alienColor = 0x00ff00; 

            const material = new THREE.MeshPhongMaterial({ color: alienColor, emissive: alienColor, emissiveIntensity: 0.3, flatShading: true });
            const darkMaterial = new THREE.MeshPhongMaterial({ color: alienColor * 0.8, emissive: alienColor * 0.2, flatShading: true });
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 1 });

            // Main Body (more angular)
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 2.5), material);
            body.position.z = -0.5;
            alien.add(body);

            // Left Arm/Wing
            const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3, 8), darkMaterial);
            leftArm.rotation.z = Math.PI / 2;
            leftArm.rotation.y = Math.PI / 8; // Angle it slightly
            leftArm.position.set(-1.5, 0, 0);
            alien.add(leftArm);

            // Right Arm/Wing
            const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3, 8), darkMaterial);
            rightArm.rotation.z = Math.PI / 2;
            rightArm.rotation.y = -Math.PI / 8; // Angle it slightly
            rightArm.position.set(1.5, 0, 0);
            alien.add(rightArm);

            // Front "Head" or Sensor
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.0, 8), material);
            head.rotation.x = -Math.PI / 2;
            head.position.z = -1.5;
            alien.add(head);

            // Lights (adjusted positions for new design)
            const lightSize = 0.2;
            const alienLight1 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMaterial);
            alienLight1.position.set(-1.0, 0.2, -1.0);
            alien.add(alienLight1);
            const alienLight2 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMaterial);
            alienLight2.position.set(1.0, 0.2, -1.0);
            alien.add(alienLight2);
            
            alien.thrusterParticles = new THREE.Group();
            const alienParticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, blending: THREE.AdditiveBlending });
            
            for(let i = 0; i < 30; i++) { 
                const alienParticleGeometry = new THREE.SphereGeometry(0.03 + Math.random() * 0.07, 6, 6); 
                const particle = new THREE.Mesh(alienParticleGeometry, alienParticleMaterial);
                particle.userData.life = Math.random() * 1 + 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 1 + 0.5
                );
                alien.thrusterParticles.add(particle);
            }
            alien.thrusterParticles.position.z = 1.5; // Position thrusters at the back of the new body
            alien.add(alien.thrusterParticles);

            alien.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, zPos);
            alien.userData.type = 'alien';
            alien.userData.health = 1;
            alien.userData.shootCooldown = ALIEN_SHOOT_COOLDOWN;
            alien.userData.laserColor = 0x00ffff; // Default laser color
            alien.userData.targetOffset = new THREE.Vector3((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 0);
            scene.add(alien);
            alienShips.push(alien);
        }

        // New: Create a second type of alien ship
        function createAlienShipType2(zPos) {
            const alien = new THREE.Group();
            const alienColor = ALIEN_TYPE2_COLOR; 

            const material = new THREE.MeshPhongMaterial({ color: alienColor, emissive: alienColor, emissiveIntensity: 0.3, flatShading: true });
            const darkMaterial = new THREE.MeshPhongMaterial({ color: alienColor * 0.8, emissive: alienColor * 0.2, flatShading: true });
            const lightMaterial = new THREE.MeshBasicMaterial({ color: ALIEN_TYPE2_LASER_COLOR, emissive: ALIEN_TYPE2_LASER_COLOR, emissiveIntensity: 1 });

            // Main Body (flatter, wider disc-like)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(2.0, 2.0, 0.5, 32), material);
            body.rotation.x = Math.PI / 2; // Flat
            alien.add(body);

            // Central dome/cockpit
            const dome = new THREE.Mesh(new THREE.SphereGeometry(1.0, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), darkMaterial);
            dome.position.z = 0.25;
            alien.add(dome);

            // Turrets/lights on the sides
            const turretGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
            const turret1 = new THREE.Mesh(turretGeo, engineMaterial);
            turret1.position.set(1.5, 0, 0);
            turret1.rotation.z = Math.PI / 2;
            alien.add(turret1);

            const turret2 = new THREE.Mesh(turretGeo, engineMaterial);
            turret2.position.set(-1.5, 0, 0);
            turret2.rotation.z = Math.PI / 2;
            alien.add(turret2);

            // Lights
            const lightSize = 0.2;
            const alienLight1 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMaterial);
            alienLight1.position.set(1.0, 0, 0.5);
            alien.add(alienLight1);
            const alienLight2 = new THREE.Mesh(new THREE.SphereGeometry(lightSize, 8, 8), lightMaterial);
            alienLight2.position.set(-1.0, 0, 0.5);
            alien.add(alienLight2);
            
            alien.thrusterParticles = new THREE.Group();
            const alienParticleMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, blending: THREE.AdditiveBlending }); // Different color thrusters
            
            for(let i = 0; i < 40; i++) { // More particles
                const alienParticleGeometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 6, 6); 
                const particle = new THREE.Mesh(alienParticleGeometry, alienParticleMaterial);
                particle.userData.life = Math.random() * 1.5 + 0.5;
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 2 + 1
                );
                alien.thrusterParticles.add(particle);
            }
            alien.thrusterParticles.position.z = -1.5; // Position thrusters at the back/bottom
            alien.add(alien.thrusterParticles);

            alien.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, zPos);
            alien.userData.type = 'alien'; // Still 'alien' for collision purposes
            alien.userData.health = ALIEN_TYPE2_HEALTH;
            alien.userData.shootCooldown = ALIEN_TYPE2_SHOOT_COOLDOWN;
            alien.userData.laserColor = ALIEN_TYPE2_LASER_COLOR; // Store laser color
            alien.userData.targetOffset = new THREE.Vector3((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, 0); // Wider target range
            scene.add(alien);
            alienShips.push(alien);
        }

        // New: Create a third type of alien ship (fast and erratic)
        function createAlienShipType3(zPos) {
            const alien = new THREE.Group();
            const alienColor = ALIEN_TYPE3_COLOR; 

            const material = new THREE.MeshPhongMaterial({ color: alienColor, emissive: alienColor, emissiveIntensity: 0.5, flatShading: true });
            const darkMaterial = new THREE.MeshPhongMaterial({ color: alienColor * 0.8, emissive: alienColor * 0.2, flatShading: true });
            const lightMaterial = new THREE.MeshBasicMaterial({ color: ALIEN_TYPE3_LASER_COLOR, emissive: ALIEN_TYPE3_LASER_COLOR, emissiveIntensity: 1 });

            // Main Body (sleek, pointed)
            const body = new THREE.Mesh(new THREE.ConeGeometry(0.8, 3.0, 8), material);
            body.rotation.x = Math.PI / 2;
            alien.add(body);

            // Small wings/stabilizers
            const wingGeo = new THREE.BoxGeometry(0.1, 1.5, 0.3);
            const wing1 = new THREE.Mesh(wingGeo, darkMaterial);
            wing1.rotation.z = Math.PI / 2;
            wing1.position.set(-0.6, 0, 0.5);
            alien.add(wing1);
            const wing2 = new THREE.Mesh(wingGeo, darkMaterial);
            wing2.rotation.z = Math.PI / 2;
            wing2.position.set(0.6, 0, 0.5);
            alien.add(wing2);

            // Front light/sensor
            const frontLight = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), lightMaterial);
            frontLight.position.z = -1.5;
            alien.add(frontLight);
            
            alien.thrusterParticles = new THREE.Group();
            const alienParticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, blending: THREE.AdditiveBlending }); // Green thrusters
            
            for(let i = 0; i < 50; i++) { // More particles for high speed
                const alienParticleGeometry = new THREE.SphereGeometry(0.04 + Math.random() * 0.08, 6, 6); 
                const particle = new THREE.Mesh(alienParticleGeometry, alienParticleMaterial);
                particle.userData.life = Math.random() * 1 + 0.3;
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    (Math.random() - 0.5) * 0.4,
                    Math.random() * 3 + 2
                );
                alien.thrusterParticles.add(particle);
            }
            alien.thrusterParticles.position.z = 1.5; // Position behind the rocket body
            alien.add(alien.thrusterParticles);

            alien.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, zPos);
            alien.userData.type = 'alien'; // Still 'alien' for collision purposes
            alien.userData.health = ALIEN_TYPE3_HEALTH;
            alien.userData.shootCooldown = ALIEN_TYPE3_SHOOT_COOLDOWN;
            alien.userData.laserColor = ALIEN_TYPE3_LASER_COLOR; // Store laser color
            alien.userData.targetOffset = new THREE.Vector3(
                (Math.random() - 0.5) * ALIEN_TYPE3_TARGET_OFFSET_RANGE, 
                (Math.random() - 0.5) * ALIEN_TYPE3_TARGET_OFFSET_RANGE, 
                0
            ); // Wider target range for erratic movement
            alien.userData.speedFactor = ALIEN_TYPE3_SPEED_FACTOR; // Store speed factor
            alien.userData.approachSpeedFactor = ALIEN_TYPE3_APPROACH_SPEED_FACTOR; // Store approach speed factor
            scene.add(alien);
            alienShips.push(alien);
        }

        // New: Create a fourth type of alien ship (Tanky and Slow)
        function createAlienShipType4(zPos) {
            const alien = new THREE.Group();
            const alienColor = ALIEN_TYPE4_COLOR; 

            const material = new THREE.MeshPhongMaterial({ color: alienColor, emissive: alienColor, emissiveIntensity: 0.3, flatShading: true });
            const darkMaterial = new THREE.MeshPhongMaterial({ color: alienColor * 0.8, emissive: alienColor * 0.2, flatShading: true });
            const lightMaterial = new THREE.MeshBasicMaterial({ color: ALIEN_TYPE4_LASER_COLOR, emissive: ALIEN_TYPE4_LASER_COLOR, emissiveIntensity: 1 });

            // Main Body (Cube-like, bulky)
            const body = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.0, 2.0), material);
            alien.add(body);

            // Large, central eye/sensor
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), lightMaterial);
            eye.position.z = -1.0;
            alien.add(eye);

            // Side cannons
            const cannonGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
            const cannon1 = new THREE.Mesh(cannonGeo, darkMaterial);
            cannon1.rotation.x = Math.PI / 2;
            cannon1.position.set(1.5, 0, 0);
            alien.add(cannon1);
            const cannon2 = new THREE.Mesh(cannonGeo, darkMaterial);
            cannon2.rotation.x = Math.PI / 2;
            cannon2.position.set(-1.5, 0, 0);
            alien.add(cannon2);
            
            alien.thrusterParticles = new THREE.Group();
            const alienParticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, blending: THREE.AdditiveBlending }); // Green thrusters
            
            for(let i = 0; i < 20; i++) { // Fewer particles as it's slow
                const alienParticleGeometry = new THREE.SphereGeometry(0.06 + Math.random() * 0.12, 6, 6); 
                const particle = new THREE.Mesh(alienParticleGeometry, alienParticleMaterial);
                particle.userData.life = Math.random() * 2 + 1;
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.5 + 0.2
                );
                alien.thrusterParticles.add(particle);
            }
            alien.thrusterParticles.position.z = 1.5; // Position behind the body
            alien.add(alien.thrusterParticles);

            alien.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, zPos);
            alien.userData.type = 'alien'; // Still 'alien' for collision purposes
            alien.userData.health = ALIEN_TYPE4_HEALTH;
            alien.userData.shootCooldown = ALIEN_TYPE4_SHOOT_COOLDOWN;
            alien.userData.laserColor = ALIEN_TYPE4_LASER_COLOR; // Store laser color
            alien.userData.targetOffset = new THREE.Vector3(
                (Math.random() - 0.5) * ALIEN_TYPE4_TARGET_OFFSET_RANGE, 
                (Math.random() - 0.5) * ALIEN_TYPE4_TARGET_OFFSET_RANGE, 
                0
            ); // More precise targeting
            alien.userData.speedFactor = ALIEN_TYPE4_SPEED_FACTOR; // Store speed factor
            alien.userData.approachSpeedFactor = ALIEN_TYPE4_APPROACH_SPEED_FACTOR; // Store approach speed factor
            scene.add(alien);
            alienShips.push(alien);
        }

        // Function to create a single random asteroid, now using RANDOM_SPAWN_AREA_RADIUS
        function createRandomAsteroid(zPos) {
            const obstacle = createAsteroid();
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * RANDOM_SPAWN_AREA_RADIUS; // Use the general spawn radius
            obstacle.position.set(
                Math.cos(angle) * r,
                Math.sin(angle) * r,
                zPos + (Math.random() - 0.5) * 100 // Spread along Z
            );
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // Modified to spawn any collectible type, including crystals, randomly
        function spawnRandomPowerup(zPos) {
            const randomType = COLLECTIBLE_TYPES[Math.floor(Math.random() * COLLECTIBLE_TYPES.length)];
            const collectible = createCollectible(randomType);

            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * RANDOM_SPAWN_AREA_RADIUS; // Use the general spawn radius

            collectible.position.set(
                Math.cos(angle) * r,
                Math.sin(angle) * r,
                zPos + (Math.random() - 0.5) * 50 // Spread along Z
            );
            scene.add(collectible);
            collectibles.push(collectible);
        }


        function createAsteroid() {
            // Randomize color for more interesting asteroids
            const colors = [
                0x888888, // Grey
                0x777777,
                0x666666,
                0x555555,
                0x998877, // Brownish
                0x776655,
                0xAA7766, // Reddish
                0x775555
            ];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Create a slightly emissive material
            const rockMaterial = new THREE.MeshPhongMaterial({ 
                color: randomColor, 
                emissive: randomColor, 
                emissiveIntensity: 0.1, // Subtle glow
                flatShading: true 
            });

            // Increase size variation
            const size = 1.5 + Math.random() * 4; // Wider range for size
            let geometry;
            const type = Math.random();
            // Randomize segments for more varied asteroid shapes
            const segments = 1 + Math.floor(Math.random() * 2); // 1 or 2 segments for low poly look

            if (type < 0.33) {
                geometry = new THREE.DodecahedronGeometry(size, segments);
            } else if (type < 0.66) {
                geometry = new THREE.IcosahedronGeometry(size, segments);
            } else {
                geometry = new THREE.OctahedronGeometry(size, segments);
            }
            
            const obstacle = new THREE.Mesh(geometry, rockMaterial);
            obstacle.userData.type = 'obstacle';
            obstacle.userData.rotationSpeed = new THREE.Vector3(Math.random() * 0.02 - 0.01, Math.random() * 0.02 - 0.01, Math.random() * 0.02 - 0.01);
            return obstacle;
        }
        
        function createCollectible(type = null) { // Added type parameter
            const randomType = type || COLLECTIBLE_TYPES[Math.floor(Math.random() * COLLECTIBLE_TYPES.length)];
            let collectibleGroup = new THREE.Group(); // Use a group for complex collectibles
            let material;

            switch (randomType) {
                case 'shield':
                    material = new THREE.MeshPhongMaterial({ color: 0x66ccff, emissive: 0x66ccff, emissiveIntensity: 1.5, transparent: true, opacity: 0.5 }); 
                    let shieldSphere = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), material); 
                    collectibleGroup.add(shieldSphere);
                    break;
                case 'health':
                    material = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.5, flatShading: true }); 
                    let horizontalBar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 0.5), material);
                    let verticalBar = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.5), material);
                    collectibleGroup.add(horizontalBar);
                    collectibleGroup.add(verticalBar);
                    break;
                case 'boost':
                    material = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.8, flatShading: true }); 
                    let boostCylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.2, 8), material); 
                    collectibleGroup.add(boostCylinder);
                    break;
                case 'tripleShot':
                    material = new THREE.MeshPhongMaterial({ color: 0xaa00ff, emissive: 0xaa00ff, emissiveIntensity: 1.5, flatShading: true }); 
                    let sphere1 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), material);
                    sphere1.position.set(-0.5, 0, 0);
                    let sphere2 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), material);
                    sphere2.position.set(0.5, 0, 0);
                    let sphere3 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), material);
                    sphere3.position.set(0, 0.8, 0); // Arranged in a triangle
                    collectibleGroup.add(sphere1, sphere2, sphere3);
                    break;
                case 'speedBoost':
                    material = new THREE.MeshPhongMaterial({ color: 0x00ffaa, emissive: 0x00ffaa, emissiveIntensity: 1.5, flatShading: true }); 
                    let cone = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.5, 8), material);
                    cone.rotation.x = Math.PI / 2; // Pointing forward
                    let cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 8), material);
                    cylinder.rotation.x = Math.PI / 2;
                    cylinder.position.z = 0.75; // Connect to the cone
                    collectibleGroup.add(cone, cylinder);
                    break;
                case 'crystal':
                default:
                    material = new THREE.MeshPhongMaterial({ color: 0x44ffaa, emissive: 0x44ffaa, emissiveIntensity: 1.5, flatShading: true }); 
                    let crystal = new THREE.Mesh(new THREE.OctahedronGeometry(0.7, 0), material);
                    collectibleGroup.add(crystal);
                    break;
            }
            
            collectibleGroup.userData.type = 'collectible';
            collectibleGroup.userData.collectibleType = randomType;
            // Add a rotation speed for the group
            collectibleGroup.userData.rotationSpeed = new THREE.Vector3(Math.random() * 0.02 - 0.01, Math.random() * 0.02 - 0.01, Math.random() * 0.02 - 0.01);
            return collectibleGroup;
        }
        
        // Modified fireLaser to accept a laserColor parameter
        function fireLaser(position, isPlayerLaser = true, laserColor = 0x00ffff) {
            if (isPlayerLaser) {
                sounds.laser.triggerAttackRelease('C7', '32n');
                if (isTripleShotActive) {
                    const laser1 = createSingleLaser(position, true, laserColor);
                    laser1.position.x -= 0.5;
                    const laser2 = createSingleLaser(position, true, laserColor);
                    const laser3 = createSingleLaser(position, true, laserColor);
                    laser3.position.x += 0.5;
                    lasers.push(laser1, laser2, laser3);
                    scene.add(laser1, laser2, laser3);
                } else {
                    const laser = createSingleLaser(position, true, laserColor);
                    lasers.push(laser);
                    scene.add(laser);
                }
            } else {
                sounds.alienLaser.triggerAttackRelease('F4', '32n');
                const laser = createSingleLaser(position, false, laserColor); // Pass laserColor
                lasers.push(laser);
                scene.add(laser);
            }
        }

        // Modified createSingleLaser to use the passed laserColor
        function createSingleLaser(position, isPlayerLaser, laserColor) {
            const laserMaterial = new THREE.MeshBasicMaterial({ color: isPlayerLaser ? 0xff3333 : laserColor, emissive: isPlayerLaser ? 0xff3333 : laserColor, emissiveIntensity: 1.5 });
            const laserGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8); 
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.rotation.x = Math.PI / 2;
            laser.position.copy(position);
            laser.position.z -= 1;
            laser.userData.isPlayerLaser = isPlayerLaser;
            return laser;
        }

        // New: Create a rocket object
        function createRocket(position) {
            const rocketGroup = new THREE.Group();
            const rocketMaterial = new THREE.MeshPhongMaterial({ color: 0xdddddd, emissive: 0x888888, flatShading: true });
            const tipMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444, emissive: 0xcc0000, flatShading: true });
            const engineMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, emissive: 0x111111, flatShading: true });

            // Body
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 2.5, 8), rocketMaterial);
            rocketGroup.add(body);

            // Tip
            const tip = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.0, 8), tipMaterial);
            tip.position.y = 1.75; // Position above body
            rocketGroup.add(tip);

            // Fins
            const finGeometry = new THREE.BoxGeometry(0.1, 1.0, 0.8);
            const fin1 = new THREE.Mesh(finGeometry, engineMaterial);
            fin1.position.set(0, -1.0, 0.6);
            rocketGroup.add(fin1);
            const fin2 = new THREE.Mesh(finGeometry, engineMaterial);
            fin2.position.set(0, -1.0, -0.6);
            rocketGroup.add(fin2);
            const fin3 = new THREE.Mesh(finGeometry, engineMaterial);
            fin3.rotation.y = Math.PI / 2;
            fin3.position.set(0.6, -1.0, 0);
            rocketGroup.add(fin3);
            const fin4 = new THREE.Mesh(finGeometry, engineMaterial);
            fin4.rotation.y = Math.PI / 2;
            fin4.position.set(-0.6, -1.0, 0);
            rocketGroup.add(fin4);


            rocketGroup.rotation.x = Math.PI / 2; // Point rocket forward
            rocketGroup.position.copy(position);
            rocketGroup.position.z -= 5; // Launch slightly ahead of player
            rocketGroup.userData.type = 'rocket';
            rocketGroup.userData.distanceTraveled = 0;
            rocketGroup.userData.initialZ = position.z; // Store initial Z for distance calculation
            
            // Add a small thruster particle effect for the rocket
            rocketGroup.thrusterParticles = new THREE.Group();
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, blending: THREE.AdditiveBlending });
            for(let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 6, 6);
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.userData.life = Math.random() * 0.5 + 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 5 + 3
                );
                rocketGroup.thrusterParticles.add(particle);
            }
            rocketGroup.thrusterParticles.position.z = 1.5; // Position behind the rocket body
            rocketGroup.add(rocketGroup.thrusterParticles);

            scene.add(rocketGroup);
            rockets.push(rocketGroup);
        }


        function createExplosion(position) {
            if (explosionSoundCooldown <= 0) {
                sounds.explosion.triggerAttackRelease("8n");
                explosionSoundCooldown = 0.1;
            }
            
            const particleCount = 50; 
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa33, transparent: true, blending: THREE.AdditiveBlending });
            
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            scene.add(explosionGroup);

            for(let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particle.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                particle.userData.life = Math.random() * 0.8 + 0.4; 
                explosionGroup.add(particle);
            }

            let explosionLife = 1;
            const explosionInterval = setInterval(() => {
                explosionLife -= 0.05;
                if (explosionLife <= 0) {
                    clearInterval(explosionInterval);
                    scene.remove(explosionGroup);
                } else {
                    explosionGroup.children.forEach(particle => {
                        particle.position.addScaledVector(particle.userData.velocity, clock.getDelta());
                        particle.material.opacity = explosionLife;
                        particle.scale.multiplyScalar(1.05); 
                    });
                }
            }, 16);
        }

        let cameraShakeIntensity = 0;
        function applyCameraShake(intensity, duration) {
            cameraShakeIntensity = intensity;
            setTimeout(() => {
                cameraShakeIntensity = 0;
            }, duration);
        }

        function updatePlayer(delta) {
            const acceleration = 50 * delta, maxSpeed = 15;
            if (keys['arrowleft'] || keys['a']) playerVelocity.x = Math.max(playerVelocity.x - acceleration, -maxSpeed);
            else if (keys['arrowright'] || keys['d']) playerVelocity.x = Math.min(playerVelocity.x + acceleration, maxSpeed);
            else playerVelocity.x *= 0.92;
            if (keys['arrowup'] || keys['w']) playerVelocity.y = Math.min(playerVelocity.y + acceleration, maxSpeed);
            else if (keys['arrowdown'] || keys['s']) playerVelocity.y = Math.max(playerVelocity.y - acceleration, -maxSpeed);
            else playerVelocity.y *= 0.92;
            
            const isBoosting = keys[' '] && boost > 0;
            if (isBoosting) {
                boostSpeed = 1.2;
                boost = Math.max(0, boost - 35 * delta);
                player.thrusterParticles.children.forEach(p => {
                    p.userData.velocity.z = Math.random() * 4 + 2;
                    p.scale.set(1.5, 1.5, 1.5); 
                });
                if (!isBoostingSoundPlaying) {
                    sounds.boost.triggerAttack();
                    isBoostingSoundPlaying = true;
                }
            } else {
                boostSpeed = 0;
                boost = Math.min(100, boost + 12 * delta);
                player.thrusterParticles.children.forEach(p => {
                    p.userData.velocity.z = Math.random() * 2 + 1;
                    p.scale.set(1, 1, 1); 
                });
                if (isBoostingSoundPlaying) {
                    sounds.boost.triggerRelease();
                    isBoostingSoundPlaying = false;
                }
            }

            if (laserCooldown > 0) laserCooldown -= delta;
            if (keys['x'] && laserCooldown <= 0) {
                fireLaser(player.position.clone());
                laserCooldown = isTripleShotActive ? 0.1 : 0.2;
            }

            // New: Rocket activation
            if (keys['z'] && bombs > 0 && bombReady && gameState === 'playing') {
                bombs = 0; // Use the bomb
                bombReady = false; // Bomb is no longer ready
                bombCooldownTimer = BOMB_USE_COOLDOWN; // Start cooldown timer
                bombRegenTimer = 0; // Reset regen timer
                sounds.bomb.triggerAttackRelease('2n'); // Play bomb sound (now rocket launch sound)
                createRocket(player.position.clone()); // Launch a rocket
                keys['z'] = false; // Prevent continuous activation
            }
            
            player.position.x += playerVelocity.x * delta * (1 + boostSpeed);
            player.position.y += playerVelocity.y * delta * (1 + boostSpeed);
            
            const boundary = 50;
            player.position.x = Math.max(-boundary, Math.min(boundary, player.position.x));
            player.position.y = Math.max(-boundary, Math.min(boundary, player.position.y));
            
            player.rotation.z = -(playerVelocity.x / maxSpeed) * 0.5;
            player.rotation.y = (playerVelocity.y / maxSpeed) * 0.5;
            
            let currentBaseSpeed = baseSpeed;
            if (isSpeedBoostActive) {
                currentBaseSpeed += SPEED_BOOST_FACTOR;
            }
            speed = currentBaseSpeed + boostSpeed;

            player.thrusterParticles.children.forEach(p => {
                p.position.z += p.userData.velocity.z * delta;
                p.userData.life -= delta;
                p.material.opacity = p.userData.life / (Math.random() * 1.5 + 0.5);
                if (p.userData.life <= 0) {
                    p.position.set(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        0
                    );
                    p.userData.life = Math.random() * 1.5 + 0.5;
                }
            });

            updateBombs(delta); // Update bomb regeneration
        }

        function updateBombs(delta) {
            if (!bombReady) {
                if (bombCooldownTimer > 0) {
                    bombCooldownTimer = Math.max(0, bombCooldownTimer - delta);
                } else {
                    // Cooldown is over, start regenerating
                    bombRegenTimer += delta;
                    if (bombRegenTimer >= BOMB_REGEN_DURATION) {
                        bombs = 1;
                        bombReady = true;
                        bombRegenTimer = 0;
                    }
                }
            }
        }

        // Renamed from activateBomb to handle rocket explosion logic
        function rocketExplode(rocketPosition) {
            sounds.explosion.triggerAttackRelease("8n"); // Play explosion sound
            createExplosion(rocketPosition.clone()); // Create visual explosion

            // Clear obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                if (rocketPosition.distanceTo(obstacle.position) < ROCKET_EXPLOSION_RADIUS) {
                    createExplosion(obstacle.position.clone());
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                    score += 50; // Award points for destroyed obstacles
                }
            }

            // Clear alien ships
            for (let i = alienShips.length - 1; i >= 0; i--) {
                const alien = alienShips[i];
                if (rocketPosition.distanceTo(alien.position) < ROCKET_EXPLOSION_RADIUS) {
                    createExplosion(alien.position.clone());
                    scene.remove(alien);
                    alienShips.splice(i, 1);
                    score += 200; // Award points for destroyed aliens
                }
            }
        }

        function updateLasers(delta) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                if (laser.userData.isPlayerLaser) {
                    laser.position.z -= 100 * delta;
                    if (laser.position.z < player.position.z - 200) {
                        scene.remove(laser);
                        lasers.splice(i, 1);
                    }
                } else {
                    laser.position.z += ALIEN_LASER_SPEED * delta;
                    if (laser.position.z > player.position.z + 50) {
                        scene.remove(laser);
                        lasers.splice(i, 1);
                    }
                }
            }
        }

        // New: Update rockets
        function updateRockets(delta) {
            for (let i = rockets.length - 1; i >= 0; i--) {
                const rocket = rockets[i];
                rocket.position.z -= ROCKET_SPEED * delta;
                rocket.userData.distanceTraveled = rocket.userData.initialZ - rocket.position.z;

                // Update rocket thruster particles
                rocket.thrusterParticles.children.forEach(p => {
                    p.position.z += p.userData.velocity.z * delta;
                    p.userData.life -= delta;
                    p.material.opacity = p.userData.life / (Math.random() * 0.5 + 0.2);
                    if (p.userData.life <= 0) {
                        p.position.set(
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            0
                        );
                        p.userData.life = Math.random() * 0.5 + 0.2;
                    }
                });

                if (rocket.userData.distanceTraveled >= ROCKET_FUSE_DISTANCE) {
                    rocketExplode(rocket.position.clone()); // Explode the rocket
                    scene.remove(rocket);
                    rockets.splice(i, 1);
                }
            }
        }

        function updateAlienShips(delta) {
            currentAlienSpawnTimer -= delta;
            if (currentAlienSpawnTimer <= 0) {
                const numAliensToSpawn = 1 + Math.floor(Math.random() * 2); // Spawn 1 to 3 aliens
                for (let i = 0; i < numAliensToSpawn; i++) {
                    const spawnZ = player.position.z - 400 - Math.random() * 200;
                    // Slightly offset multiple aliens spawned at once
                    const offsetX = (Math.random() - 0.5) * 20; 
                    const offsetY = (Math.random() - 0.5) * 20;

                    const alienTypeRoll = Math.random();
                    if (alienTypeRoll < 0.4) { // 40% chance for Type 1 alien
                        createAlienShip(spawnZ + i * 10); 
                    } else if (alienTypeRoll < 0.7) { // 30% chance for Type 2 alien (0.4 to 0.7)
                        createAlienShipType2(spawnZ + i * 10);
                    } else if (alienTypeRoll < 0.9) { // 20% chance for Type 3 alien (0.7 to 0.9)
                        createAlienShipType3(spawnZ + i * 10);
                    } else { // 10% chance for Type 4 alien (0.9 to 1.0)
                        createAlienShipType4(spawnZ + i * 10);
                    }
                    alienShips[alienShips.length - 1].position.x += offsetX;
                    alienShips[alienShips.length - 1].position.y += offsetY;
                }
                currentAlienSpawnTimer = alienSpawnCooldown + Math.random() * 5;
            }

            for (let i = alienShips.length - 1; i >= 0; i--) {
                const alien = alienShips[i];
                
                // Apply speed factor for different alien types
                const alienMoveSpeedFactor = alien.userData.speedFactor || 1; // Default to 1 if not defined
                alien.position.z += (speed * delta * 5 * alienMoveSpeedFactor);
                
                const targetX = player.position.x + alien.userData.targetOffset.x;
                const targetY = player.position.y + alien.userData.targetOffset.y;
                // Apply approach speed factor for different alien types
                const approachSpeedFactor = alien.userData.approachSpeedFactor !== undefined ? alien.userData.approachSpeedFactor : 0.1; // Default to 0.1
                const approachSpeed = 5 * delta;
                alien.position.x += (targetX - alien.position.x) * approachSpeed * approachSpeedFactor;
                alien.position.y += (targetY - alien.position.y) * approachSpeed * approachSpeedFactor;

                alien.thrusterParticles.children.forEach(p => {
                    p.position.z += p.userData.velocity.z * delta;
                    p.userData.life -= delta;
                    p.material.opacity = p.userData.life / (Math.random() * 1 + 0.2);
                    if (p.userData.life <= 0) {
                        p.position.set(
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            0
                        );
                        p.userData.life = Math.random() * 1 + 0.2;
                    }
                });

                alien.userData.shootCooldown -= delta;
                if (alien.userData.shootCooldown <= 0 && alien.position.z > player.position.z - 100) {
                    // Pass alien's specific laser color
                    fireLaser(alien.position.clone(), false, alien.userData.laserColor || 0x00ffff); 
                    // Adjust cooldown based on alien type
                    if (alien.userData.health === ALIEN_TYPE2_HEALTH) {
                        alien.userData.shootCooldown = ALIEN_TYPE2_SHOOT_COOLDOWN + Math.random() * 1;
                    } else if (alien.userData.health === ALIEN_TYPE3_HEALTH) {
                        alien.userData.shootCooldown = ALIEN_TYPE3_SHOOT_COOLDOWN + Math.random() * 0.5;
                    } else if (alien.userData.health === ALIEN_TYPE4_HEALTH) {
                        alien.userData.shootCooldown = ALIEN_TYPE4_SHOOT_COOLDOWN + Math.random() * 1.5;
                    } else {
                        alien.userData.shootCooldown = ALIEN_SHOOT_COOLDOWN + Math.random() * 1;
                    }
                }

                if (alien.position.z > player.position.z + 50) {
                    scene.remove(alien);
                    alienShips.splice(i, 1);
                }
            }
        }
        
        function updateCollisions() {
            if (explosionSoundCooldown > 0) {
                explosionSoundCooldown -= clock.getDelta();
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                if (player.position.distanceTo(obstacle.position) < 2.5) {
                    if (isShieldActive) {
                        sounds.damage.triggerAttackRelease('C3', '8n');
                    } else {
                        health -= 25;
                        sounds.damage.triggerAttackRelease('A1', '8n');
                        applyCameraShake(0.5, 200);
                        if (health <= 0) { health = 0; gameOver(); }
                    }
                    createExplosion(obstacle.position);
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }
            
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                if (player.position.distanceTo(collectible.position) < 2) {
                    sounds.powerup.triggerAttackRelease('C6', '16n');
                    switch (collectible.userData.collectibleType) {
                        case 'shield':
                            isShieldActive = true;
                            player.shieldVisual.visible = true;
                            sounds.shield.triggerAttackRelease('G5', '4n');
                            clearTimeout(shieldTimeout);
                            shieldTimeout = setTimeout(() => { isShieldActive = false; player.shieldVisual.visible = false; }, 5000);
                            break;
                        case 'health':
                            health = Math.min(100, health + HEALTH_PACK_AMOUNT);
                            break;
                        case 'boost':
                            boost = 100;
                            break;
                        case 'tripleShot':
                            isTripleShotActive = true;
                            if (tripleShotTimeout) clearTimeout(tripleShotTimeout);
                            tripleShotTimeout = setTimeout(() => { isTripleShotActive = false; }, TRIPLE_SHOT_DURATION * 1000);
                            break;
                        case 'speedBoost':
                            isSpeedBoostActive = true;
                            if (speedBoostTimeout) clearTimeout(speedBoostTimeout);
                            speedBoostTimeout = setTimeout(() => { isSpeedBoostActive = false; }, SPEED_BOOST_DURATION * 1000);
                            break;
                        case 'crystal':
                        default:
                            score += 150;
                            sounds.collect.triggerAttackRelease('C5', '8n');
                            break;
                    }
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                }
            }

            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                let laserHit = false;

                if (laser.userData.isPlayerLaser) {
                    for (let j = obstacles.length - 1; j >= 0; j--) {
                        const obstacle = obstacles[j];
                        if (laser.position.distanceTo(obstacle.position) < 3) {
                            createExplosion(obstacle.position);
                            scene.remove(obstacle);
                            obstacles.splice(j, 1);
                            
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            
                            score += 50;
                            laserHit = true;
                            break;
                        }
                    }
                }
                if(laserHit) continue;

                if (laser.userData.isPlayerLaser) {
                    for (let j = alienShips.length - 1; j >= 0; j--) {
                        const alien = alienShips[j];
                        if (laser.position.distanceTo(alien.position) < 2.5) {
                            alien.userData.health--;
                            if (alien.userData.health <= 0) {
                                createExplosion(alien.position);
                                scene.remove(alien);
                                alienShips.splice(j, 1);
                                score += 200;
                            }
                            
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            laserHit = true;
                            break;
                        }
                    }
                }
                if(laserHit) continue;

                if (!laser.userData.isPlayerLaser) {
                    if (player.position.distanceTo(laser.position) < 2) {
                        if (isShieldActive) {
                            sounds.damage.triggerAttackRelease('C3', '8n');
                        } else {
                            health -= 15;
                            sounds.damage.triggerAttackRelease('A1', '8n');
                            applyCameraShake(0.3, 150);
                            if (health <= 0) { health = 0; gameOver(); }
                        }
                        scene.remove(laser);
                        lasers.splice(i, 1);
                        laserHit = true;
                        break;
                    }
                }
            }

            for (let i = alienShips.length - 1; i >= 0; i--) {
                const alien = alienShips[i];
                if (player.position.distanceTo(alien.position) < 3) {
                    if (isShieldActive) {
                        sounds.damage.triggerAttackRelease('C3', '8n');
                    } else {
                        health -= 50;
                        sounds.damage.triggerAttackRelease('A1', '8n');
                        applyCameraShake(0.8, 300);
                        if (health <= 0) { health = 0; gameOver(); }
                    }
                    createExplosion(alien.position);
                    scene.remove(alien);
                    alienShips.splice(i, 1);
                    break;
                }
            }
        }
        
        function updateEnvironment(delta) {
            const moveDistance = speed * delta * 20;
            distance += moveDistance / 100;
            if (player) {
                player.position.z -= moveDistance;
            }
            
            starfieldLayers.forEach(layer => {
                layer.position.z += moveDistance * layer.userData.speedFactor;
            });

            nebulaPlanes.forEach(nebula => {
                nebula.position.z += moveDistance * 0.01;
                if (nebula.position.z > (player ? player.position.z : 0) + 500) {
                    nebula.position.z = (player ? player.position.z : 0) - 1500 - Math.random() * 500;
                    nebula.position.x = (Math.random() - 0.5) * 1500;
                    nebula.position.y = (Math.random() - 0.5) * 1200;
                }
            });

            const distantFieldRecycleDistance = 1000;
            distantAsteroidFields = distantAsteroidFields.filter(field => {
                field.position.z += moveDistance * 0.005;
                field.children.forEach(asteroid => {
                    asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                    asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                    asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
                });

                if (field.position.z > (player ? player.position.z : 0) + distantFieldRecycleDistance) {
                    scene.remove(field);
                    return false;
                }
                return true;
            });

            if (distantAsteroidFields.length < 3 && Math.random() > 0.995) {
                createDistantAsteroidField((player ? player.position.z : 0) - 2000 - Math.random() * 1000, 50, 500);
            }

            obstacles.forEach(o => {
                o.rotation.x += o.userData.rotationSpeed.x;
                o.rotation.y += o.userData.rotationSpeed.y;
                o.rotation.z += o.userData.rotationSpeed.z;
            });

            collectibles.forEach(c => { // Rotate collectibles
                c.rotation.x += c.userData.rotationSpeed.x;
                c.rotation.y += c.userData.rotationSpeed.y;
                c.rotation.z += c.userData.rotationSpeed.z;
            });

            // Spawning random asteroids independently (more frequent)
            randomAsteroidSpawnTimer -= delta;
            if (randomAsteroidSpawnTimer <= 0) {
                createRandomAsteroid(player.position.z - 200 - Math.random() * 100); // Spawn ahead of player
                randomAsteroidSpawnTimer = RANDOM_ASTEROID_SPAWN_INTERVAL + Math.random() * 0.02; // Randomize interval (even more frequent)
            }

            // Spawning random power-ups independently (more frequent, includes crystals)
            powerupSpawnTimer -= delta;
            if (powerupSpawnTimer <= 0) {
                spawnRandomPowerup(player.position.z - 200 - Math.random() * 100); // Spawn ahead of player
                powerupSpawnTimer = POWERUP_SPAWN_INTERVAL + Math.random() * 0.3; // Randomize interval (even more frequent)
            }
            
            // Filter out objects that are too far behind the player (recycle them)
            const recycleThresholdZ = player.position.z + 50; // Objects 50 units behind the player
            
            obstacles = obstacles.filter(o => {
                if (o.position.z > recycleThresholdZ) {
                    scene.remove(o);
                    return false;
                }
                return true;
            });
            collectibles = collectibles.filter(c => {
                if (c.position.z > recycleThresholdZ) {
                    scene.remove(c);
                    return false;
                }
                return true;
            });
            alienShips = alienShips.filter(a => { 
                if (a.position.z > recycleThresholdZ) {
                    scene.remove(a);
                    return false;
                }
                return true;
            });
            rockets = rockets.filter(r => { 
                if (r.position.z > recycleThresholdZ) {
                    scene.remove(r);
                    return false;
                }
                return true;
            });
            
            baseSpeed = Math.min(2.5, 0.8 + distance * 0.0015);

            if (dynamicLight && player) {
                dynamicLight.position.x = player.position.x + Math.sin(distance * 0.01) * 50;
                dynamicLight.position.y = player.position.y + Math.cos(distance * 0.005) * 50 + 20;
                dynamicLight.position.z = player.position.z - 50;

                const orbitRadius = 70;
                const orbitSpeed = 0.002;
                secondaryDynamicLight.position.x = player.position.x + Math.sin(distance * orbitSpeed) * orbitRadius;
                secondaryDynamicLight.position.y = player.position.y + Math.cos(distance * orbitSpeed * 0.7) * orbitRadius * 0.5 + 10;
                secondaryDynamicLight.position.z = player.position.z - 80;
            }
        }
        
        function updateUI() {
            document.getElementById('score').textContent = Math.floor(score);
            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('healthBar').style.width = health + '%';
            document.getElementById('boostBar').style.width = boost + '%';
            
            const bombStatusElement = document.getElementById('bombStatus');
            const bombRegenBar = document.getElementById('bombRegenBar');

            if (bombs > 0 && bombReady) {
                bombStatusElement.textContent = 'Ready';
                bombRegenBar.style.width = '100%';
            } else if (bombCooldownTimer > 0) {
                bombStatusElement.textContent = `Cooling Down (${Math.ceil(bombCooldownTimer)}s)`;
                bombRegenBar.style.width = '0%'; // No progress during cooldown
            } else {
                bombStatusElement.textContent = `Regenerating...`;
                const progress = (bombRegenTimer / BOMB_REGEN_DURATION) * 100;
                bombRegenBar.style.width = `${progress}%`;
            }
        }
        
        function animate() {
            if (gameState !== 'playing') { // Only animate if game is playing
                return;
            }
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (player) {
                updatePlayer(delta);
                updateEnvironment(delta);
                updateLasers(delta);
                updateRockets(delta); // New: Update rockets
                updateAlienShips(delta);
                updateCollisions();
                updateUI();
                
                const cameraLag = 0.08; 
                camera.position.x += (player.position.x - camera.position.x) * cameraLag;
                camera.position.y += (player.position.y + 5 - camera.position.y) * cameraLag;
                camera.position.z = player.position.z + 25;
                camera.lookAt(player.position.x, player.position.y, player.position.z - 30);
                
                if (cameraShakeIntensity > 0) {
                    camera.position.x += (Math.random() - 0.5) * cameraShakeIntensity;
                    camera.position.y += (Math.random() - 0.5) * cameraShakeIntensity;
                }
            } else {
                console.warn("Player object not yet initialized in animate loop. Skipping updates.");
            }

            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = function() {
            // Removed init() call from here. init() will now only be called by startGame() or restartGame()
            document.querySelector('[data-type="rocket"]').click();
            console.log("Window loaded, default character selected.");
        };
    </script>
</body>
</html>
